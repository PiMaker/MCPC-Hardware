- NEG from.reg to.reg = NOT :from :to 0, ADD :to :to 1 - negates a 2's complement number, also converts from and to 2's complement
- JMPR to.reg = MOV :to PC - Jump unconditionally to an address in a register
- JMP to.lit = SET SCR1, :to, MOV SCR1 PC - Jump unconditionally to a literal address
- JMPNZ to.lit if.reg = SET SCR1, :to, MOVNZ SCR1 PC :if - Jump to "to" if if.reg is not zero
- JMPEZ to.lit if.reg = SET SCR1, :to, MOVEZ SCR1 PC :if - Jump to "to" if if.reg is equal to zero
- JMPGT to.lit val.reg cmpto.reg = SET SCR2, :to, GT :val SCR1 :cmpto, MOVNZ SCR2 PC SCR1 - Jump to "to" if val.reg is greater than cmpto.reg
- CALL addr.reg = ADD SP SP -1, MOV PC SP, MOV :addr PC, ADD SP SP 1 - Calls a function at addr.reg
- RET = MOV SP PC - Returns from a function
- STOR data.reg addr.reg = SHFT :addr SCR1 -0x7, SHFT SCR1 SCR1 0x3, OR SCR1 SCR1 1, BUS SCR1 0x1, BUS :data 0x1 - Stores data in SRAM
- LOAD data.reg addr.reg = SHFT :addr SCR1 -0x7, SHFT SCR1 SCR1 0x3, BUS SCR1 0x1, HOLD, MOV BUS :data - Retrieves data from SRAM
- INC val.reg = ADD :val :val 1 - Increments by one
- DEC val.reg = ADD :val :val -1 - Decrements by one
- NOOP = MOV SCR1 SCR1 - does nothing for one cycle
- NEG from.reg to.reg = NOT :from 0 :to, ADD :to 1 :to - negates a 2's complement number, also converts from and to 2's complement
- JMPR to.reg = MOV :to PC - Jump unconditionally to an address in a register
- JMP to.lit = SET SCR1, :to, MOV SCR1 PC - Jump unconditionally to a literal address
- JMPNZ to.lit if.reg = SET SCR1, :to, MOVNZ SCR1 PC :if - Jump to "to" if if.reg is not zero
- JMPEZ to.lit if.reg = SET SCR1, :to, MOVEZ SCR1 PC :if - Jump to "to" if if.reg is equal to zero
- JMPGT to.lit val.reg cmpto.reg = SET SCR2, :to, GT :val :cmpto SCR1, MOVNZ SCR2 PC SCR1 - Jump to "to" if val.reg is greater than cmpto.reg
- CALL addr.reg = ADD SP -1 SP, MOV PC SP, MOV :addr PC, ADD SP 1 SP - Calls a function at addr.reg
- RET = MOV SP PC - Returns from a function
- STOR data.reg addr.reg = SHFT :addr -0x7 SCR1, SHFT SCR1 0x3 SCR1, OR SCR1 1 SCR1, BUS SCR1 0x1, BUS :data 0x1 - Stores data in SRAM
- LOAD data.reg addr.reg = SHFT :addr -0x7 SCR1, SHFT SCR1 0x3 SCR1, BUS SCR1 0x1, HOLD, MOV BUS :data - Retrieves data from SRAM
- INC val.reg = ADD :val 1 :val - Increments by one
- DEC val.reg = ADD :val -1 :val - Decrements by one
- NOOP = MOV SCR1 SCR1 - does nothing for one cycle
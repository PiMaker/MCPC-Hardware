- NOT from.reg to.reg =             XOR :from :to -1 - bitwise negate
- COM from.reg to.reg =             NOT :from :to - Alias for NOT
- LT a.reg out.reg b.reg =          GT :b :out :a - Reverse GT for convenience
- SETREG to.reg val.lit =           SET :to, :val - Sets a register to a value in a single line of assembler code
- NEG from.reg to.reg =             NOT :from :to, ADD :to :to 1 - negates a 2's complement number, also converts from and to 2's complement
- SUB val.reg out.reg minus.reg =   NEG :minus SCR1, ADD :val :out SCR1 - Subtracts minus.reg from value.reg and stores result in out.reg (2's complement arithmetic)
- JMPR to.reg =                     MOV :to PC - Jump unconditionally to an address in a register
- JMP to.lit =                      SET SCR1, :to, MOV SCR1 PC - Jump unconditionally to a literal address
- GOTO to.lit =                     JMP :to - Alias for JMP
- JMPNZ to.lit if.reg =             SET SCR1, :to, MOVNZ SCR1 PC :if - Jump to "to" if if.reg is not zero
- JMPEZ to.lit if.reg =             SET SCR1, :to, MOVEZ SCR1 PC :if - Jump to "to" if if.reg is equal to zero
- JMPGT to.lit val.reg cmpto.reg =  SET SCR2, :to, GT :val SCR1 :cmpto, MOVNZ SCR2 PC SCR1 - Jump to "to" if val.reg is greater than cmpto.reg
- JMPEQ to.lit val.reg cmpto.reg =  SET SCR2, :to, EQ :val SCR1 :cmpto, MOVNZ SCR2 PC SCR1 - Jump to "to" if val.reg is equal to cmpto.reg
- JMPNQ to.lit val.reg cmpto.reg =  SET SCR2, :to, EQ :val SCR1 :cmpto, MOVEZ SCR2 PC SCR1 - Jump to "to" if val.reg is not equal to cmpto.reg
- INC val.reg =                     ADD :val :val 1 - Increments by one
- DEC val.reg =                     ADD :val :val -1 - Decrements by one
- NOOP =                            MOV SCR1 SCR1 - Does nothing for one cycle
- CHAR addr.reg data.lit =          SET SCR2, :data, STOR SCR2 :addr, INC addr - Special char syntax support for creating strings manually in text form
- CALL func.lit =                   DEC SP, SET SCR2, :func, STOR PC SP, MOV SCR2 PC, ADD SP SP 1 - Calls a function at addr.reg
- RET =                             LOAD SCR1 SP, INC SCR1, INC SCR1, MOV SCR1 PC - Returns from a function
- PUSH val.reg =                    DEC SP, STOR :val SP - Stack push
- POP val.reg =                     LOAD :val SP, INC SP - Stack pop
- FAULT num.lit =                   SETREG SCR1 0xFA00, SETREG H :num, OR H H SCR1, HALT - Faults and halts the CPU displaying an error code on the hex display (H)
- GTOE a.reg out.reg b.reg =        GT :a SCR1 :b, EQ :a SCR2 :b, OR SCR1 :out SCR2 - Greater than or equal
- LTOE a.reg out.reg b.reg =        GTOE :b :out :a - Lower than or equal
- NEQ a.reg out.reg b.reg =         EQ :a :out :b, NOT :out :out - Not equal
- SHFR val.reg out.reg by.reg =     SHFT :val :out :by - Logical shift right
- SHFL val.reg out.reg by.reg =     SETREG SCR1 0xFF00, OR SCR1 SCR1 :by, SHFT :val :out SCR1 - Logical shift left